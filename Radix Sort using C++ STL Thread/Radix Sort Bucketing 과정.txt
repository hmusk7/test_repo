<Radix 정렬, 버켓 이용>
170, 45, 75, 90, 2, 802, 2, 66
(170,90) (2,802,2)(45,75),(66)
bucket_0 = 170, 90
bucket_1 = 2,802,2
bucket_5 = 45,75
bucket_6 = 66

170, 90, 2, 802, 2, 45, 75, 66
bucket_0 = 02, 802, 02
bucket_4 = 45
bucket_5 = 66
bucket_7 = 170, 75
bucket_9 = 90

02, 802, 02, 45, 66, 170, 75, 90
bucket_0 = 02, 02, 45, 66, 75, 90
bucket_1 = 170
bucket_8 = 802

02, 02, 45, 66, 75, 90, 170, 802

1. 인덱스 값을 이용하는 방법 (어떻게 할지 모르겠음)
2. max 값을 구한 뒤, 루프의 개수대로 ThreadManager를 통해 스레드를 생성한 뒤 해제하고, 각 자리를 카운트해서 버켓을 동적으로 생성하고, 버켓의 수 만큼 ThreadManager를 통해 스레드를 생성한 뒤 각 버켓에 전부 담고, 합치고, 스레드는 해제하고. if 문을 활용할 필요 없이, 스레드 번호와 버켓의 번호를 일치시키고, 스레드를 생성할 때 스레드 벡터의 번호에 맞게 i번째 버켓에 i자리의 값이 담기게 함. 이후, for 문을 통해 memcpy로 하나의 배열로 합침.

ThreadManager 클래스
1. 스레드 저장
2. 스레드 초기화
3. 스레드 cv 관리, 삭제
4. 스레드가 처리할 태스크 관리
5. 스레드 루프 분할 처리 함수 (루프 횟수 / threadnum 구해서 각 범위 range 배열에 넣고, range 배열에 따라 처리)

RadixSort 함수
1. 배열 중 max 값 구해서 자릿수 구하기 -> for문 range 분할해서 병렬화
2. 10자리인 경우, 10번 루프를 통해, 각 자리마다 버켓화를 진행할 것임
3. 버켓화는 우선 배열의 값을 순회하며 각 자리의 값을 count 한다.
4. count[0] = 20이면, bucket[0] = new int[20] 을 통해 각 버켓을 동적으로 할당한다.
5. 다시한번 배열의 값을 순회하며 int digit 을 얻어내고, bucket[digit] = arr[i] 을 넣어준다.
6. bucket 들을 전부 통합한다. 

ThreadManager: 스레드 생성 및 할당, 삭제 등
TaskManager:
1. 태스크큐 푸시, 태스크큐 팝, 태스크 파티셔닝, 태스크를 위한 스레드 관리
2. 태스크큐에 접근할땐 반드시 lock으로 접근
RadixVariable: Radix 관련 변수 저장 및 생성자 담당

RadixSort 함수:
1. for 파티셔닝해서 max값 구하고 RadixVariable의 max 배열에 저장 (병렬 스레드) v
2. max 배열의 결과값들 비교해서 최종적으로 max값 산출 (main 스레드) v
3. for 루프로 exp*=10 을 계속 나눠가며 count++ 하여 자릿수 구하고, RadixVariable 의 exp에 저장 (main 스레드) v
4. 자릿수 exp 값만큼 버켓팅: for 파티셔닝해서 배열의 값 순회하며 각 자리의 값 RadixVariable의 Count 배열에 저장 (병렬 스레드) v
5. for 루프를 0~9까지 10번하여 각 버켓을 new int[count[i]] 로 동적 할당 (main 스레드) v
6. 루프 안에 for 파티셔닝해서 배열의 값 순회하며 각 exp 의 int digit 을 얻어내고, bucket[digit] = arr[i] 를 통해 넘겨줌. (병렬 스레드)
7. arr[] 배열에 bucket 을 통합해서 저장, 다음 자릿수 exp 루프를 실행
8. 최종적으로 arr[] 배열 출력

딱히 각 단계를 함수로 만들 필요가 없다. (각각 호출해서 쓰는게 아니기 때문)
근데 각 태스크를 분할해서 큐에 집어넣을 수는 있다.

전역 변수:
int* arr, int size // 배열, 배열 크기
std::vector<int*> bucket; // 총 10개
int* bucketSize; // 버켓 10개의 각각 크기 저장

지역 변수:
int max // 최댓값 저장
int maxDigit // 최댓값의 자릿수값 저장 (예를 들어, 최댓값이 1000이면, 네자리 수, 루프 횟수에 사용됨)
long long int radix // 기수, 10, maxDigit 을 구할 때 사용됨
long long int currDigit = pow(radix, i) // 현재 정렬할 자릿수값
int* bkt // 버켓 사이즈대로 생성한, 벡터 버켓 배열에 넣어줄 버켓
int num // 배열을 currDigit 으로 나누고, % 10 연산해서 구한 현재 자리의 숫자
int numIndex[10] = { 0 }; // 각 0~9 num 버켓에 하나씩 차곡차곡 저장하기 위해 Index 값을 올리기 위해 사용
int* mergedBucket // 각각 저장된 버켓들을 하나로 통합할 버켓



함수: 
<SearchMaxDigit()>
SearchMax (병렬화 필요)
SearchMaxDigit
<RadixSort()>
CalculateBucketSize (병렬화 필요)
AllocateBuckets
StoreBuckets (병렬화 필요)
ConcatenateBuckets (병렬화 필요)


cv 를 이용하니 문제점: 모든 스레드가 wait 상태가 되기 전부터 메인 스레드에서 업무를 할당하고 태스크큐에 푸쉬될때 스레드들에게 notify 해주는데, 메인 스레드가 너무 빨리 처리해보면 스레드들이 wait 상태가 되버리기 전에 notify 해버려 작업을 처리하지않음.
따라서 notify_all 하여 언제든 태스크가 찼을 때 하나씩 담당해서 하게 하려고 했으나,
절차적으로 해야하기 때문에 이런 방식으로 하면 첫번째에 처리해야할 것보다 다른 스레드가 두번째에 처리할걸 먼저 처리해버리는 문제점이 생김